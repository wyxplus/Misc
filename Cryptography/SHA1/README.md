# 一、SHA1 信息摘要过程

##  0. 变量解释

​      buffer: 明文

​      $W_0 ... W_{79}$

​      $H_0 ... H_4$： 最后摘要结果

##  1. 明文填充

​      \- 明文后先补一个 1，然后再补 0，直到长度满足对 512 取模后余数是 448

​      \- 再补一个明文长度（64 bits）

##  2. 分块（将明文分成 512 bits 为单位的块$M_1$, $M_2$, ... , $M_n$）



## 3. 处理每个 $M_i$ （关键）

1. 初始化 $H_0, H_1, H_2, H_3, H_4$

2. $M_i$ 分成 16 个块 $\{W_0, W_1, ..., W_{15}\}$

3. t = 16~79

​        $W_t = S^{(1)}\{W_{t-3} \bigoplus W_{t-8} \bigoplus W_{t-14} \bigoplus W_{t-16}\}$

4. t = 0~79

​        $TEMP = S^{(5)}A + f_t(B, C, D) + E + W_t + K_t$

​        E = D

​        D = C

​        $C = S^{(30)}B$

​        B = A

​        A = TEMP

5. $H_0 += A, H_1 += B, H_2 += C, H_3 += D, H_4 += E$



# 二、源码简单注释

源码来源：https://github.com/vog/sha1

```c++
// SHA1类公有函数
void update(xxx); // 明文输入入口
std::string final(); // 计算摘要并返回摘要
static std::string from_file(const std::string &filename); // 文件输入入口
```

源码中一些 trick：

1. R0，R1，R2，R3，R4 函数是对 $W_0 ... W_{79}$ 操作的函数，其中 R0 是对处理 $M_{i}$ 步骤 2 3 4 的合并操作。R1、R2、R3、R4 函数则是步骤 3  和 4 的合并。因此，R0 执行 16 次，R1 执行 4 次，R2 执行 20 次，R3 执行 20 次，R4 执行 20次。

2. 对中间过程的变量进行优化，由 $W_0 ... W_{79}$ 80 个 uint32_t 变量减小到 uint32_t  block[16] 16 个。因为步骤 3 的 $W_i$ 的计算范围是 16，可与步骤 4 合并则无需保留已使用的计算结果。